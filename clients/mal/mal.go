// Package mal wraps the underlying MAL API client and return database entries.
//
// N.B.: While the caller may set Manga.List and Anime.List limits, this limit
// is actually a minimum -- the actual number of returned results varies between
// the given limit and the API max of 100.
//
// N.B.: MAL HTTP response includes a NextOffset field -- this field is actually
// reset to 0 upon reaching the end if the query, and will need to be explicitly
// handled (as otherwise any loop checking the length of returned results will
// loop forever).
//
// TODO(github.com/nstratos/go-myanimelist/pull/8): Add support for configurable NSFW searches.
package mal

import (
	"context"
	"math"
	"net/http"
	"strconv"
	"strings"

	"github.com/minkezhang/truffle/api/go/database/utils"
	"github.com/nstratos/go-myanimelist/mal"

	dpb "github.com/minkezhang/truffle/api/go/database"
)

const (
	// clientID is the publically-known MAL API, per
	// https://github.com/SuperMarcus/myanimelist-api-specification#requests.
	//
	// This API key may also be generated by creating an account and
	// requesting developer access.
	clientID = "6114d00ca681b7701d1e15fe11a4987e"

	// MaxResults sets a limit on the number of results returned by the MAL
	// API. It appears the MAL search endpoints weights results by a
	// matching heuristic, meaning the first couple of matches are much more
	// likely to be useful for the user.
	MaxResults = 50
)

type C mal.Client

func New() *C {
	c := C(*mal.NewClient(
		&http.Client{
			Transport: t{clientID: clientID},
		},
	))
	return &c
}

var (
	// lookup is a reverse lookup table from MAL "media_type" to an
	// associated dpb.Corpus value.
	//
	// See https://myanimelist.net/apiconfig/references/api/v2 for potential
	// media_type valus.
	lookup = map[string]dpb.Corpus{
		"tv":      dpb.Corpus_CORPUS_ANIME,
		"ova":     dpb.Corpus_CORPUS_ANIME,
		"ona":     dpb.Corpus_CORPUS_ANIME,
		"special": dpb.Corpus_CORPUS_ANIME,
		"movie":   dpb.Corpus_CORPUS_ANIME_FILM,

		// MAL lists the "novel" type but experimentally, this is
		// "light_novel" instead.
		"light_novel": dpb.Corpus_CORPUS_BOOK,

		"manga":     dpb.Corpus_CORPUS_MANGA,
		"one_shot":  dpb.Corpus_CORPUS_MANGA,
		"doujinshi": dpb.Corpus_CORPUS_MANGA,
		"manhua":    dpb.Corpus_CORPUS_MANGA,
		"manhwa":    dpb.Corpus_CORPUS_MANGA,
		"oel":       dpb.Corpus_CORPUS_MANGA,
	}
)

func (c *C) AnimeSearch(ctx context.Context, title string, corpus dpb.Corpus, popularity int) ([]*dpb.Entry, error) {
	f := func(r *mal.Response) ([]mal.Anime, *mal.Response, error) {
		if r != nil && r.NextOffset == 0 {
			return nil, nil, nil
		}
		var offset int
		if r != nil {
			offset = r.NextOffset
		}
		results, r, err := (*mal.Client)(c).Anime.List(
			ctx, title,
			mal.Fields{
				"media_type",
				"popularity",
				"title",
				"mean",
				"studios",
			},
			mal.Limit(math.Min(100, MaxResults)),
			mal.Offset(offset),
		)
		return results, r, err
	}

	var results []mal.Anime
	var err error

	for page, r, err := f(nil); err == nil && page != nil && len(results) <= MaxResults; page, r, err = f(r) {
		results = append(results, page...)
	}
	if err != nil {
		return nil, err
	}

	var epbs []*dpb.Entry
	for _, r := range results {
		// Trim obscure series.
		if popularity >= 0 && r.Popularity >= popularity {
			continue
		}
		if corpus != lookup[r.MediaType] {
			continue
		}

		epb := &dpb.Entry{
			Id:     utils.ID(dpb.API_API_MAL, strconv.FormatInt(int64(r.ID), 10)),
			Titles: []string{r.Title},
			Score:  float32(r.Mean),
			Corpus: corpus,
		}

		var studios []string
		for _, s := range r.Studios {
			studios = append(studios, s.Name)
		}
		epb.AuxData = &dpb.Entry_AuxDataVideo{
			AuxDataVideo: &dpb.AuxDataVideo{
				Studios: studios,
			},
		}

		epbs = append(epbs, epb)
	}

	return epbs, nil
}

func (c *C) MangaSearch(ctx context.Context, title string, corpus dpb.Corpus, popularity int) ([]*dpb.Entry, error) {
	f := func(r *mal.Response) ([]mal.Manga, *mal.Response, error) {
		if r != nil && r.NextOffset == 0 {
			return nil, nil, nil
		}
		var offset int
		if r != nil {
			offset = r.NextOffset
		}
		results, r, err := (*mal.Client)(c).Manga.List(
			ctx, title,
			mal.Fields{
				"media_type",
				"popularity",
				"title",
				"alternative_titles",
				"mean",
				"authors{first_name,last_name}",
			},
			mal.Limit(math.Min(100, MaxResults)),
			mal.Offset(offset),
		)
		return results, r, err
	}

	var results []mal.Manga
	var err error

	for page, r, err := f(nil); err == nil && page != nil && len(results) <= MaxResults; page, r, err = f(r) {
		results = append(results, page...)
	}
	if err != nil {
		return nil, err
	}

	var epbs []*dpb.Entry
	for _, r := range results {
		// Trim obscure series.
		if popularity >= 0 && r.Popularity >= popularity {
			continue
		}
		if corpus != lookup[r.MediaType] {
			continue
		}

		epb := &dpb.Entry{
			Id:     utils.ID(dpb.API_API_MAL, strconv.FormatInt(int64(r.ID), 10)),
			Titles: []string{r.Title},
			Score:  float32(r.Mean),
			Corpus: corpus,
		}

		for _, t := range r.AlternativeTitles.Synonyms {
			epb.Titles = append(epb.GetTitles(), t)
		}

		var authors []string
		for _, a := range r.Authors {
			var names []string
			for _, n := range []string{a.Person.FirstName, a.Person.LastName} {
				if n != "" {
					names = append(names, n)
				}
			}
			authors = append(authors, strings.Join(names, " "))
		}
		epb.AuxData = &dpb.Entry_AuxDataBook{
			AuxDataBook: &dpb.AuxDataBook{
				Authors: authors,
			},
		}
		epbs = append(epbs, epb)
	}

	return epbs, nil
}

type t struct {
	clientID string
}

func (t t) RoundTrip(req *http.Request) (*http.Response, error) {
	req.Header.Add("X-MAL-CLIENT-ID", t.clientID)
	return http.DefaultTransport.RoundTrip(req)
}
