// Package mal wraps the underlying MAL API client and return database entries.
//
// TODO(github.com/nstratos/go-myanimelist/pull/8): Add support for configurable NSFW searches.
package mal

import (
	"context"
	"net/http"
	"strconv"
	"strings"

	"github.com/minkezhang/truffle/api/go/database/utils"
	"github.com/nstratos/go-myanimelist/mal"

	dpb "github.com/minkezhang/truffle/api/go/database"
)

const (
	// clientID is the publically-known MAL API, per
	// https://github.com/SuperMarcus/myanimelist-api-specification#requests.
	//
	// This API key may also be generated by creating an account and
	// requesting developer access.
	clientID = "6114d00ca681b7701d1e15fe11a4987e"
)

type C mal.Client

func New() *C {
	c := C(*mal.NewClient(
		&http.Client{
			Transport: t{clientID: clientID},
		},
	))
	return &c
}

var (
	// lookup is a reverse lookup table from MAL "media_type" to an
	// associated dpb.Corpus value.
	//
	// See https://myanimelist.net/apiconfig/references/api/v2 for potential
	// media_type valus.
	lookup = map[string]dpb.Corpus{
		"tv":      dpb.Corpus_CORPUS_ANIME,
		"ova":     dpb.Corpus_CORPUS_ANIME,
		"ona":     dpb.Corpus_CORPUS_ANIME,
		"special": dpb.Corpus_CORPUS_ANIME,
		"movie":   dpb.Corpus_CORPUS_ANIME_FILM,

		// MAL lists the "novel" type but experimentally, this is
		// "light_novel" instead.
		"light_novel": dpb.Corpus_CORPUS_BOOK,

		"manga":     dpb.Corpus_CORPUS_MANGA,
		"one_shot":  dpb.Corpus_CORPUS_MANGA,
		"doujinshi": dpb.Corpus_CORPUS_MANGA,
		"manhua":    dpb.Corpus_CORPUS_MANGA,
		"manhwa":    dpb.Corpus_CORPUS_MANGA,
		"oel":       dpb.Corpus_CORPUS_MANGA,
	}
)

func (c *C) AnimeSearch(ctx context.Context, title string, corpus dpb.Corpus, popularity int) ([]*dpb.Entry, error) {
	results, _, err := (*mal.Client)(c).Anime.List(
		ctx, title,
		mal.Fields{
			"media_type",
			"popularity",
			"title",
			"mean",
			"studios",
		},
	)
	if err != nil {
		return nil, err
	}

	var epbs []*dpb.Entry
	for _, r := range results {
		// Trim obscure series.
		if popularity >= 0 && r.Popularity >= popularity {
			continue
		}
		if corpus != lookup[r.MediaType] {
			continue
		}

		epb := &dpb.Entry{
			Id:     utils.ID(dpb.API_API_MAL, strconv.FormatInt(int64(r.ID), 10)),
			Titles: []string{r.Title},
			Score:  float32(r.Mean),
			Corpus: corpus,
		}

		var studios []string
		for _, s := range r.Studios {
			studios = append(studios, s.Name)
		}
		epb.AuxData = &dpb.Entry_AuxDataVideo{
			AuxDataVideo: &dpb.AuxDataVideo{
				Studios: studios,
			},
		}

		epbs = append(epbs, epb)
	}

	return epbs, nil
}

func (c *C) MangaSearch(ctx context.Context, title string, corpus dpb.Corpus, popularity int) ([]*dpb.Entry, error) {
	results, _, err := (*mal.Client)(c).Manga.List(
		ctx, title,
		mal.Fields{
			"media_type",
			"popularity",
			"title",
			"alternative_titles",
			"mean",
			"authors{first_name,last_name}",
		},
	)
	if err != nil {
		return nil, err
	}

	var epbs []*dpb.Entry
	for _, r := range results {
		// Trim obscure series.
		if popularity >= 0 && r.Popularity >= popularity {
			continue
		}
		if corpus != lookup[r.MediaType] {
			continue
		}

		epb := &dpb.Entry{
			Id:     utils.ID(dpb.API_API_MAL, strconv.FormatInt(int64(r.ID), 10)),
			Titles: []string{r.Title},
			Score:  float32(r.Mean),
			Corpus: corpus,
		}

		for _, t := range r.AlternativeTitles.Synonyms {
			epb.Titles = append(epb.GetTitles(), t)
		}

		var authors []string
		for _, a := range r.Authors {
			var names []string
			for _, n := range []string{a.Person.FirstName, a.Person.LastName} {
				if n != "" {
					names = append(names, n)
				}
			}
			authors = append(authors, strings.Join(names, " "))
		}
		epb.AuxData = &dpb.Entry_AuxDataBook{
			AuxDataBook: &dpb.AuxDataBook{
				Authors: authors,
			},
		}
		epbs = append(epbs, epb)
	}

	return epbs, nil
}

type t struct {
	clientID string
}

func (t t) RoundTrip(req *http.Request) (*http.Response, error) {
	req.Header.Add("X-MAL-CLIENT-ID", t.clientID)
	return http.DefaultTransport.RoundTrip(req)
}
